# Мемоизация в React

Мемоизация - это техника оптимизации, которая заключается в сохранении результатов вычислений для использования их повторно вместо повторного выполнения тех же вычислений. В реакте она полезна, когда нет необходимости каждый раз перерисовывать сложный компонент. Получаем профит в виде _сэкономленных ресурсов пользователя_ + _скорости работы страницы_

Рассмотрю мемоизацию на примере функции `React.memo`

### Плюсы:
- Уменьшение повторного рендеринга компонента.

- Использование кастомной функции сравнения.

В React мемоизация компонента вызывается с помощью `React.memo`, который позволяет кэшировать компоненты и обновлять их только при изменении пропсов (дефолтное поведение).

```tsx
const MemoizedComponent = React.memo(({prop}) => {
    return (
        <div>{prop}</div>
    );
});

const App = () => {
    const data = 'Hello, world!';

    return (
        <>
            <MemoizedComponent prop={data}/>
        </>
    );
};

export default App;
```

При использовании `memo` компонент будет рендериться заново только при изменении `prop`

Вдобавок изменения детектируются с помощью функции `Object.is()`, если не указывать функцию сравнения `arePropsEqual`. Отсюда очевидно использование `memo` с параметром `arePropsEqual` в случаях, когда на сам объект ссылка поменялась, а его свойства - нет.

```tsx
const Chart = memo(function Chart({dataPoints}) {
    // ...
}, arePropsEqual);

function arePropsEqual(oldProps, newProps) {
    return (
        oldProps.dataPoints.length === newProps.dataPoints.length &&
        oldProps.dataPoints.every((oldPoint, index) => {
            const newPoint = newProps.dataPoints[index];
            return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;
        })
    );
}
```

### Тонкости

- При использовании `arePropsEqual` стоит быть осторожным с проведением чересчур глубоких сравнений:

  > “Избегайте проведения глубоких сравнений внутри arePropsEqual, если вы не уверены на 100%, что структура данных, с которой вы работаете, имеет известную ограниченную глубину. Глубокие сравнения могут стать невероятно медленными и могут замораживать ваше приложение на несколько секунд, если кто-то изменит структуру данных позже.”

- Стоит также учитывать, что если дочерний компонент обернут в `memo`, то при отрисовке родительского компонента _дочерний компонент может быть заново отрисован_, поскольку `memo` - это не гарантия, а оптимизация. 

- Всего одно “всегда новое” свойство может сделать бессмысленными любую оптимизацию.

